<div align="center">
  
  ![header](https://capsule-render.vercel.app/api?type=waving&color=timeAuto&height=180&section=header&text=Priority%20Queue&fontSize=70)
  ### 우선순위 큐
</div>

<br/>

## 🖥️ 개요

### 📌 우선순위 큐란?
- Queue + Data Priority
- 우선 순위가 높은 데이터가 먼저 빠져나가는 원리.
- 핵심: "데이터의 우선 순위를 무엇으로 잡을 것인가?"
- 데이터 들어온 시각을 우선순위로? => 일반적인 큐처럼 작동.
- 이용 분야 : `시뮬레이션 시스템` - 우선순위(사건의 시각), `네트워크 트래픽 제어`, `OS 작업 스케쥴링` etc.
- 구현 방법 : `Array`, `LinkedList`, **`Heap`**

### 📌 ADT
- 객체 : n개의 element형의 우선 순위를 가진 요소들의 모임
- 연산 : 
    > - **create()** : 우선순위 큐 생성 연산.
    > - **init(q)** : 우선순위 큐 q 초기화 연산.
    > - **is_empty(q)** : 우선순위 큐 q 공백 검사 연산.
    > - **is_full(q)** : 우선순위 큐 q 가득 찼는가 검사 연산.
    > - **insert(q,x)** : 우선순위 큐 q에 요소 x 추가 연산.
    > - **delete(q)** : 우선순위 큐로부터 가장 우선순위가 높은 요소 삭제 및 반환.
        > 최소 우선순위 큐 : min(우선순위) 기준.
        > 최대 우선순위 큐 : max(우선순위) 기준.
    > - **find(q)** : 우선순위가 가장 높은 요소 반환.

<br/>

## 🖥️ 구현 방법

### 📌 배열
- 정렬 x 배열의 경우?
    > 삽입 : 배열의 맨 끝에 새로운 요소 추가.<br/>
    > 삭제 : 가장 우선 순위가 높은 요소를 찾기 위해, 모든 요소 탐색.<br/><br/>
    > **시간복잡도**
    > - 삽입 : O(1)
    > - 삭제 : O(n)

- 정렬 O 배열의 경우?
    > 삽입 : 삽입 위치 탐색 + 삽입 위치 뒤의 요소들 이동 및 삽입<br/>
    > 삭제 : 맨 뒤 요소 삭제.<br/><br/>
    > **시간복잡도**
    > - 삽입 : O(n)
    > - 삭제 : O(1)

### 📌 연결 리스트
- 정렬 x 리스트의 경우?
    > 삽입 : 1번째 노드로 삽입(이게 유리하기 때문) + 헤드 포인터 변경 <br/>
    > 삭제 : 포인터를 따라 모든 노드 탐색.<br/><br/>
    > **시간복잡도** 
    > - 삽입 : O(1)
    > - 삭제 : O(n)

- 정렬 o 리스트의 경우?
    > 삽입 : 우선 순위 높은 요소 앞에 위치 + 삽입위치 탐색 필요.<br/>
    > 삭제 : 1번째 노드 삭제.<br/><br/>
    > **시간복잡도**
    > - 삽입 : O(n)
    > - 삭제 : O(1)

### 📌 히프
[개요]
- 우선순위 큐를 위해 특별히 제작된 자료 구조.
- 완전 이진 트리의 일종
- **일종의 느슨한 정렬 상태 유지**
- 완전 정렬은 아니지만, 정렬이 안된 것도 아닌 상태.
- 시간복잡도(삽입 및 삭제) : O(log n)

[개념]
- 여러 개의 값들 중에서 가장 큰값 또는 가장 작은값을 빠르게 찾아내는 자료구조.
- 다음 조건을 통해 종류가 나뉨.
    - Key(부모노드) >= Key(자식노드) : `최대 히프` (Max Heap)
    - Key(부모노드) <= Key(자식노드) : `최소 히프` (Min Heap)
- 완전 이진 트리의 특성 + 중복값 허용. (이진 탐색 트리에서는 중복값 허용 x)

[구현]
- `배열` : 완전 이진 트리 -> 각 노드에 차례대로 넘버링. (이를 배열의 인덱스로 적용.)
- 쉬운 구현을 위해, **배열의 1번째 인덱스인 0은 사용하지 않음.**
- 자식노드와 부모노드 인덱스 파악?
    > - Left Children Index = (Parent Index) * 2
    > - Right Children Index = (Parent Index) * 2 + 1
    > - Parent Index = (Children) / 2
    > <br/>
    > **K진 트리의 인덱스 파악?**
    > - Children Index = (i*k) - (k-2)
    > - Parent Index = (i+k-2) / k
