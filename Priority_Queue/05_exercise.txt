[1]
Q) 히프트리에서 노드가 삭제되는 위치?
A) Root Node

[2]
Q) 히프를 배열로 표현가능한 이유?
A) 완전 이진 트리이므로, 노드에 넘버링 가능.

[3]
Q) 히프 연산 중에서 하나의 노드가 삽입되거나 삭제되는 시간은 무엇에 비례하는가?
- S1 : 노드의 개수
- S2 : 트리의 높이
- S3 : 항상 일정
- S4 : 예측 불가능
A)
=> 히프의 삽입과 삭제는 트리의 깊이만큼 탐색하므로, O(log n)의 시간복잡도를 가짐.
=> 그러므로, S2가 정답이다.

[4]
Q) 다음 중, 히프 정렬이 특히 유용하게 사용되는 경우?
- S1 : 데이터 100개 중, 오름차순으로 20개만 뽑고자 할때
- S2 : 비교적 데이터의 개수가 적을 때
- S3 : 정렬의 대상이 되는 레코드의 크기가 클때
- S4 : 데이터가 역순으로 정렬되어 있을 때 
A)
=> 히프는 최소 또는 최대값을 몇개만 뽑는 경우에 효율적이다.
=> 히프는 느슨한 정렬상태를 유지하기 때문이기 때문.
=> 다시 말해, 전체 정렬은 O(n * log n)이지만, 일부분은 O(필요한 개수 * log n)이다.
=> 그러므로, S1이 정답이다.

[5]
Q) 최소 히프에서 가장 작은 데이터가 있는 노드?
A) Root Node

[6]
Q) 최소 히프에서 2번째로 작은 데이터가 있는 노드?
A) 2번째 노드(Root의 left child) 또는 3번째 노드(Root의 right child)

[7]
Q) 10개의 데이터를 저장하고 있는 히프트리의 높이?
A1) 트리이므로, h<=n<=2**h-1 표현 가능.
A2) h<=n and log(n+1)<=h
A3) A2를 정리하면, log(n+1)<=h<=n이고, log(10+1)<=h<=10이다.
A4) 완전이진트리이므로, h>=log(10+1)의 최소값을 구해야 한다.
A5) h<=3.xx 이므로, 정답은 4이다. 

[8]
Q) 최소 히프를 구현한 배열의 내용이 다음과 같을 때, 히프트리 그려라.

a[i] : 1 9 3 15 10 7 8 16 22

Q1) 삭제 연산 한번 수행후 배열의 내용은?
A1) 3 9 7 15 10 20 8 16

Q2) A1에서 7을 삽입한 후의 배열 내용은?
A2) 3 7 7 9 10 20 8 16 15