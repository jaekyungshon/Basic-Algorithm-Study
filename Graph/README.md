<div align="center">
  
  ![header](https://capsule-render.vercel.app/api?type=waving&color=timeAuto&height=180&section=header&text=Graph&fontSize=70)
  ### 그래프
</div>

<br/>

## 🖥️ 그래프 이론

### 📌 그래프 정의
- `정점과 간선들의 유한 집합`, `Vertex`, `Edge`, `G = (V,E) | <V,E>`
- Vertex : 여러 가지 특성을 가질 수 있는 객체
- Edge : 정점들 간의 관계
- 종류
  - `무방향 그래프` : 간선을 통해 양방향 통행 가능 (표현: (A,B))
  - `방향 그래프` : 방향이 있는 간선을 통한 일방통행 가능 (표현: <A,B>)
  - `네트워크` 또는 `가중치 그래프` : 간선의 역할 = 정점 간 연결 유무 + 연결 강도(ex 비용, 가중치, etc)
  - `부분 그래프` : 정점의 일부와 간선의 일부로 이루어진 그래프
  - `연결 그래프` : 모든 정점 쌍에 대하여 항상 경로가 존재하는 그래프 (완전 그래프에 포함됨. 일치 x)
    ```
    Tree : Cycle을 가지지 않는 그래프의 특수한 형태. 연결 그래프의 일종
    ```
  - `완전 그래프` : 모든 정점이 서로 연결되어 있는 그래프
- 구성
  - 정점의 차수
    > - 인접 정점 : 간선에 의해 직접 연결된 정점
    > - 차수 : 해당 정점의 인접정점 수 (in 무방향 그래프)
    > - 진입 차수 : 외부에서 오는 간선의 개수 (in 방향 그래프)
    > - 진출 차수 : 외부로 향하는 간선의 개수 (in 방향 그래프)
- 경로
  - 단순 경로(Simple Path) : 경로 중, 반복 간선이 없는 경우
  - 사이클(Cycle) : 단순 경로의 시작정점과 종료 정점이 동일한 경로
- 구현 방법 : `인접행렬`, `인접 리스트`

### 📌 ADT
- 객체 : 정점의 집합 + 간선의 집합
- 연산:
  > - **create_graph()** : 그래프 생성 연산.
  > - **init(g)** : 그래프 g 초기화 연산.
  > - **insert_vertex(g,v)** : 그래프 g에 정점 v를 삽입하는 연산.
  > - **insert_edge(g,u,v)** : 그래프  g에 간선 (u,v)를 삽입하는 연산.
  > - **delete_vertex(g,v)** : 그래프 g의 정점 v를 삭제하는 연산.
  > - **delete_edge(g,u,v)** : 그래프 g의 간선 (u,v)를 삭제하는 연산.
  > - **is_empty(g)** : 그래프 g의 공백 여부 검사 연산.
  > - **adjacent(v)** : 정점 v에 인접한 정점들의 리스트 반환.
  > - **destory_graph(g)** : 그래프 g 제거 연산.

<br/>

## 🖥️ 구현 방법

### 📌 인접 행렬(Adgacency Matrix)
- `2차원 배열`
- (그래프의 정점 수 n) n x n의 2차원 배열을 통해, 다음과 같이 표현.

  ```
  if(간선 (i,j)가 그래프에 존재)  M[i][j]=1,
  else                          M[i][j]=0
  ```
- 특징
  > - 무방향 그래프에서의 인접 행렬은 대칭 행렬을 이룬다. (M[i][j]=1 and M[j][i]=0)
  > - 정점의 차수 : 해당 정점의 열들을 모두 합한다. (M[0][0]+M[0][1]+...+M[0][n])
  > - 간선의 수와 무관하게 n*n개의 메모리 공간 필요.
  > - 밀집 그래프 효율적 but, 희소 그래프 비효율적
  > - 간선의 존재 여부 확인 시간복잡도 : O(1)
  > - 정점의 차수 시간복잡도 : O(n)
  > - 모든 간선의 수 탐색 시간복잡도: O(n*n)

### 📌 인접 리스트(Adjacency List)
- `연결 리스트` (LinkedList)
- 하나의 배열에 정점 개수만큼의 헤더 노드 존재.
- 각각의 헤더 노드를 갖는 연결 리스트의 노드들은 인접 정점들을 저장.

  ```
  GraphNode* adj_list[Vertices_size]
  ```
- 특징
  > - 각 연결 리스트에 입력되는 순서에 따라 연결 리스트 내 정점들의 순서가 달라질 수 있다.
  > - (정점 개수 n개, 간선의 수 e개, 무방향 그래프) n개의 헤더노드 + 2e개의 노드 필요.
  > - 간선의 개수가 적은 희소 그래프 표현에 적합.
  > - 전체 간선의 수 탐색 시간복잡도 : O(n+e)

<br/>

## 🖥️ 그래프 탐색 기법

### 📌 DFS(Depth-First-Search)
- 한 정점의 방향으로 끝까지 탐색하는 기법.
- 더 이상 갈 수 없다면, **다시 가장 가까운 갈림길로 되돌아오는** 방법을 사용.
  ```
  BackTracking : 최근 방문한 곳으로 되돌아가는 기법.
  ```
- 탐색 과정 예제
  - 1번째 과정
    - 
### 📌 BFS(Breath-First-Search)
