<div align="center">
  
  ![header](https://capsule-render.vercel.app/api?type=waving&color=timeAuto&height=180&section=header&text=Graph&fontSize=70)
  ### 그래프
</div>

<br/>

## 🖥️ 그래프 이론

### 📌 그래프 정의
- `정점과 간선들의 유한 집합`, `Vertex`, `Edge`, `G = (V,E) | <V,E>`
- Vertex : 여러 가지 특성을 가질 수 있는 객체
- Edge : 정점들 간의 관계
- 종류
  - `무방향 그래프` : 간선을 통해 양방향 통행 가능 (표현: (A,B))
  - `방향 그래프` : 방향이 있는 간선을 통한 일방통행 가능 (표현: <A,B>)
  - `네트워크` 또는 `가중치 그래프` : 간선의 역할 = 정점 간 연결 유무 + 연결 강도(ex 비용, 가중치, etc)
  - `부분 그래프` : 정점의 일부와 간선의 일부로 이루어진 그래프
  - `연결 그래프` : 모든 정점 쌍에 대하여 항상 경로가 존재하는 그래프 (완전 그래프에 포함됨. 일치 x)
    ```
    Tree : Cycle을 가지지 않는 그래프의 특수한 형태. 연결 그래프의 일종
    ```
  - `완전 그래프` : 모든 정점이 서로 연결되어 있는 그래프
- 구성
  - 정점의 차수
    > - 인접 정점 : 간선에 의해 직접 연결된 정점
    > - 차수 : 해당 정점의 인접정점 수 (in 무방향 그래프)
    > - 진입 차수 : 외부에서 오는 간선의 개수 (in 방향 그래프)
    > - 진출 차수 : 외부로 향하는 간선의 개수 (in 방향 그래프)
- 경로
  - 단순 경로(Simple Path) : 경로 중, 반복 간선이 없는 경우
  - 사이클(Cycle) : 단순 경로의 시작정점과 종료 정점이 동일한 경로
- 구현 방법 : `인접행렬`, `인접 리스트`

### 📌 ADT
- 객체 : 정점의 집합 + 간선의 집합
- 연산:
  > - **create_graph()** : 그래프 생성 연산.
  > - **init(g)** : 그래프 g 초기화 연산.
  > - **insert_vertex(g,v)** : 그래프 g에 정점 v를 삽입하는 연산.
  > - **insert_edge(g,u,v)** : 그래프  g에 간선 (u,v)를 삽입하는 연산.
  > - **delete_vertex(g,v)** : 그래프 g의 정점 v를 삭제하는 연산.
  > - **delete_edge(g,u,v)** : 그래프 g의 간선 (u,v)를 삭제하는 연산.
  > - **is_empty(g)** : 그래프 g의 공백 여부 검사 연산.
  > - **adjacent(v)** : 정점 v에 인접한 정점들의 리스트 반환.
  > - **destory_graph(g)** : 그래프 g 제거 연산.

<br/>

## 🖥️ 구현 방법

### 📌 인접 행렬(Adgacency Matrix)
- `2차원 배열`
- (그래프의 정점 수 n) n x n의 2차원 배열을 통해, 다음과 같이 표현.

  ```
  if(간선 (i,j)가 그래프에 존재)  M[i][j]=1,
  else                          M[i][j]=0
  ```
- 특징
  > - 무방향 그래프에서의 인접 행렬은 대칭 행렬을 이룬다. (M[i][j]=1 and M[j][i]=0)
  > - 정점의 차수 : 해당 정점의 열들을 모두 합한다. (M[0][0]+M[0][1]+...+M[0][n])
  > - 간선의 수와 무관하게 n*n개의 메모리 공간 필요.
  > - 밀집 그래프 효율적 but, 희소 그래프 비효율적
  > - 간선의 존재 여부 확인 시간복잡도 : O(1)
  > - 정점의 차수 시간복잡도 : O(n)
  > - 모든 간선의 수 탐색 시간복잡도: O(n*n)

### 📌 인접 리스트(Adjacency List)
- `연결 리스트` (LinkedList)
- 하나의 배열에 정점 개수만큼의 헤더 노드 존재.
- 각각의 헤더 노드를 갖는 연결 리스트의 노드들은 인접 정점들을 저장.

  ```
  GraphNode* adj_list[Vertices_size]
  ```
- 특징
  > - 각 연결 리스트에 입력되는 순서에 따라 연결 리스트 내 정점들의 순서가 달라질 수 있다.
  > - (정점 개수 n개, 간선의 수 e개, 무방향 그래프) n개의 헤더노드 + 2e개의 노드 필요.
  > - 간선의 개수가 적은 희소 그래프 표현에 적합.
  > - 전체 간선의 수 탐색 시간복잡도 : O(n+e)

<br/>

## 🖥️ 그래프 탐색 기법

### 📌 DFS(Depth-First-Search)
- 한 정점의 방향으로 끝까지 탐색하는 기법.
- 더 이상 갈 수 없다면, **다시 가장 가까운 갈림길로 되돌아오는** 방법을 사용.
  ```
  BackTracking : 최근 방문한 곳으로 되돌아가는 기법.
  ```
- 탐색 과정 예제
  - *1번째 과정*
    - <img src="https://github.com/jaekyungshon/Basic-Algorithm-Study/assets/61006212/1feece51-ee43-4956-8ac5-3b79eb2b5803" width="300" height="300" alt="dfs_01">
    - 최상단 노드인 0부터 왼쪽 자식을 기준으로 끝까지 탐색을 진행.
  - *2번째 과정*
    - <img src="https://github.com/jaekyungshon/Basic-Algorithm-Study/assets/61006212/60792a2b-f598-4992-afc9-b2f9cb84b54f" width="300" height="300" alt="dfs_02">
    - 3은 말단 노드이므로, 최근에 방문됬던 3의 부모노드인 1로 백트래킹.
    - 이후, 1노드의 다른자식(오른쪽 자식)인 4를 방문.
  - *3번째 과정 ~*
    -  <img src="https://github.com/jaekyungshon/Basic-Algorithm-Study/assets/61006212/782ff37e-885a-4eab-9269-fc6365d15e1f" width="300" height="300" alt="dfs_03">
    -  4도 말단 노드이므로, 부모 노드인 1로 백트래킹.
    -  부모 노드 1도 방문했으므로, 1의 부모 노드인 0으로 백트래킹.
    -  0의 다른 자식 즉, 오른쪽 자식인 2는 미방문이므로, 탐색 진행.
    -  이런식으로, DFS 탐색 과정이 진행.
- 구현 방식
  - `Recursion` : 자기 자신의 자식노드를 타고 들어가므로, 순환 알고리즘을 이용.
  - `Stack` : 재귀는 시스템 호출의 기본 형식인 스택을 사용하므로, 명시적 스택 사용 가능.

### 📌 BFS(Breath-First-Search)
- 시작 정점으로부터 가장 가까운 정점들을 먼저 탐색하는 기법.
- `레벨 순회` : 부모노드의 자식노드들을 모두 방문하므로, 그래프의 한 레벨에 존재하는 노드들을 먼저 순회하는 것과 같다.
- 탐색 과정 예제
  - <img src="https://github.com/jaekyungshon/Basic-Algorithm-Study/assets/61006212/b188ab23-229d-42be-9839-93c8e2d904a2" width="300" height="300" alt="bfs">
  - 최상단 노드 0의 left / right 자식노드인 1과 2를 차례로 방문.
  - left 자식노드인 1의 자식노드 3과 4 방문.
  - right 자식노드인 2의 자식노드 5와 6 방문.
- 구현 방식
  - `Queue` : 가장 가까운 정점들을 방문한 후, 이 정점들의 자식노드들을 차례대로 탐색해야하기 때문에, 선입선출 특징을 가진 큐 사용.

### 📌 DFS vs BFS
- DFS와 BFS의 공통된 시간 복잡도
  ```
  N이 노드의 개수, E가 간선의 개수일 때,

  인접 행렬 구현 : O(N+E)
  인접 리스트 : O(N*N)
  ```
- 상황별 활용
  - *모든 정점을 방문?*
    - DFS 또는 BFS 사용 가능.
  - *경로를 저장?*
    - 일반적으로, 한 정점을 기준으로 타고 들어가는 DFS 유리.
    - 단, 어떤 경로를 최소의 시간으로 방문하고자 하는 경우, BFS 유리.
      > - Tip
      > - a에서 b까지 가는데 있어, 최소의 시간으로 방문하고자 가정.
      > - 거리가 최소이다. == 시작정점에서 종료정점까지의 그래프 높이가 최소이다.
      > - 즉, 최소를 찾기 위해서는 BFS의 레벨순회 특징이 유리.
      > - 그렇다면 BFS의 경로는 어떻게 저장해야하는가?
      > - Queue의 원소에 '부모노드를 누적시킨 배열'을 추가로 넣어준다.
  - *검색 대상 그래프의 규모가 크다?*
    - DFS가 유리.
    - 시작 및 종료 정점이 끝과 끝인 경우, bfs는 그만큼 시간이 많이 걸림.
  - *가중치가 없는 최단 경로 DFS vs BFS?*
    - 무조건 BFS
    - DFS(해 보장 x) vs BFS(해 보장 O)
    - 즉, 특정 칸에 처음 도달했을 때의 경로의 길이보다 다른 경로로 도착한 길이보다 짧다는 보장이 안되기 때문.
